#!/bin/bash
## docker-enter
## @author gdm85
## @author jpetazzo
##
## this is an heavily modified version from jpetazzo's original
## it uses /proc/*/environ to retrieve a correct container environment
## and then performs other sorcerery tricks to setup an usable shell
## both for interactive ad non-interactive use within containers
##
#

if [ -z "$1" ]; then
	echo "Usage: docker-enter CONTAINER [COMMAND [ARG]...]"
	echo ""
	echo "Enters the Docker CONTAINER and executes the specified COMMAND."
	echo "If COMMAND is not specified, runs an interactive shell in CONTAINER."
	exit 1
fi

BASENAME=$(dirname $(readlink -m $0)) || exit $?


function create_env_args() {
	local PID="$1"
	echo -n "HOME=/root USER=root UID=0 LOGNAME=root USERNAME=root TERM=$TERM"
	## space is necessary
	echo -n " "
	## carefully filter out empty environment variables
	## Dockerfile does not allow clearing environment variables, so we will set them to ""
	cat /proc/$PID/environ | xargs -0 | sed -r -e 's~[A-Za-z0-9_]+=("")? ~~g'
	return ${PIPESTATUS[0]}
}

function docker_nsenter() {
	local PID
	local ENV
	local OPTS
	local NSE
	local CID="$1"
	shift 1

	PID=$(docker inspect --format "{{.State.Pid}}" "$CID") || return $?
	if [[ -z "$PID" || "$PID" == "<no value" || "$PID" == "0" ]]; then
		return 1
	fi

	## environment override
	ENV="$(create_env_args $PID)" || return $?

	## get absolute path to nsenter
	NSE=$(whereis -b nsenter | awk '{ print $2 }')
	test ${PIPESTATUS[0]} -eq 0 || return 1
	test -z "$NSE" && return 2

	OPTS="--target $PID --mount --uts --ipc --net --pid -F"

	env --ignore-environment $ENV $NSE $OPTS -- "$@"
}

CID="$1"
shift

if [ $# -eq 0 ]; then
	echo "--> docker-enter: now entering container $CID with an interactive shell" 1>&2
	docker_nsenter "$CID" su -m -l -- root
else
	docker_nsenter "$CID" "$@"
fi
